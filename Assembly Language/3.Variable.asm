%include "io64.inc"

section .text
global main
main:
    ; 참고) 지난 파일에 적었던 레지스터 종류
    ; eax: Extended Accumulator Register, 사칙/논리연산에 일반적으로 사용되는 저장 공간
    ; ebx: 메모리 주소 저장
    ; ecx: 반복 구문(for/while)에서 반복횟수 저장
    ; edx: ax와 함께 사용되며 데이터 저장용. 부호 확장/큰 수 연산에서 사용
    ; 64비트 버전: rax, rbx, rcx, rdx
    ; 16비트 버전: ax, bx, cx, dx
    ;  ㄴ 각각 8비트의 (ah,al), (bh,bl), (ch,cl), (dh,dl) 로 구성
    
    ;-------------------------------------------------------------------------------
    
    ; F5로 디버그 모드 실행 후, 상단 [Debug - Show Memory] (Ctrl+M)을 눌러 메모리 디버깅 가능
    ; 변수나 메모리 주소를 입력해서 값을 볼 수 있다. 메모리 주소로 보려면 우측 Address를 체크할 것.

    ;-------------------------------------------------------------------------------
    
    ; 이전 파일에서 사용한 mov 명령으로 a값을 rax 레지스터로 이동시켜본다
    mov rax, a
    
    ; 이후 rax를 보면 a 변수에 할당한 값과 다른 값이 들어있는 것을 볼 수 있다.
    ; 왜냐면 rax에 들어있는 값은 a 변수가 들어있는 메모리의 주소이기 때문
    
    ; 데이터 주소만 참조하는 게 아니라, 값을 실제로 복사해서 레지스터에 올리려면 [변수] 와 같이 입력한다.
    mov rax, [a]
    
    ; 이후 rax를 보면 0x4433333333222211 값이 들어있다.
    ; 얼만큼 읽으라고 지정하지 않았기 때문에, a는 1바이트 변수지만 rax 레지스터 크기에 맞게 8바이트를 읽은 것.
    
    ; 1바이트 레지스터만 지정해서 a변수의 값을 옮겨보면 제대로 값이 들어올 것이다.
    mov al, [a]
    
    ; 변수에 값을 직접 옮길때도 [변수] 형태로 사용한다
    mov [a], byte 0x55 ; 리터럴 입력 시 크기를 명시해야 함
    
    ; 변수 범위 초과하는 값을 입력하면 그냥 메모리 옆 공간까지 침범해서 들어간다.
    ; 지정한 주소에 값을 순차적으로 쓰는 것뿐이기 때문.
    mov [a], word 0x6666 ; a 옆의 1바이트 공간에도 0x66이 들어가서 변수 b는 0x2222 에서 0x6622가 된다.
    
    ; 레지스터에 들어있는 값을 변수에 옮길수도 있다.
    mov cl, 0xff ; cl 레지스터에 0xff값을 저장
    mov [a], cl ; cl 레지스터의 값 0xff가 변수 a에 들어감

    xor rax, rax
    ret
    
section .data
; data : 메모리에서 초기화된 데이터의 영역. 변수 선언 시 이름, 크기, 초기값을 지정해야 한다.
    ; 형식: {변수명} {크기} {초기값}
    ;  ㄴ 크기: db(1바이트), dw(2바이트), dd(3바이트), dq(8바이트)
    a db 0x11 ; a라는 이름의 1바이트 변수, 초기값은 16진수로 11이 들어있다.
    b dw 0x2222
    c dd 0x33333333
    d dq 0x4444444444444444
    
section .bss
; bss : 메모리에서 초기화되지 않은 데이터의 영역. 변수 선언 시 이름, 크기, 개수를 지정해야 한다.
    ; 형식: {변수명} {크기} {개수}
    ;  ㄴ 크기: resb(1바이트), resw(2), resd(4), resq(8)
    e resb 10
    