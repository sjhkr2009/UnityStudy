# 6. 전략 (행동 패턴 / Strategy, Policy)

"동일 계열의 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하며, 이들을 상호교환이 가능하도록 만듭니다. 알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 합니다."

활용성
- 환경에 따라 동일한 행동에 대해 서로 다른 동작을 제공해야 할 때
- 필요한 알고리즘만 제공하거나 알고리즘에 사용되는 복잡한 자료구조를 숨기고 싶을 때

구현
- Context: 알고리즘을 사용하고, 알고리즘에 필요한 데이터를 제공한다.
- Strategy: 여러 알고리즘에 공통적으로 정의된 인터페이스
- ConcreteStrategy: Strategy의 인터페이스를 사용해서 실제로 구현된 동작

장점
- 알고리즘의 기능들에 공통된 부분이 있다면 상속을 통해 재사용할 수 있다. 
- Context에 다중 조건문을 두거나 Context를 상속하는 형태에 비해 코드가 간결해지고 유지보수가 쉬워진다.

주의할 점
- 각 전략은 인터페이스를 통해 필요한 데이터를 제공받는데, 특정 알고리즘은 필요하지 않은 데이터도 전달받는 오버헤드가 발생한다.
- 전략마다 별도의 클래스를 구현하여 객체 수가 증가하며, 사용자가 전략을 선택하려면 각 구현 내용을 모두 알고 있어야 한다.

활용 예시
- 리그 오브 레전드의 챔피언 '아펠리오스'는 5개의 무기를 번갈아 사용하는데, 사용중인 무기에 따라 패시브, 기본 공격, 스킬이 달라진다.
- 전략 패턴을 이용하여 사용자 측에서 공통의 인터페이스만 호출해서 각 무기에 맞는 동작을 사용할 수 있게 할 수 있다.

예제 구현
- IWeaponStrategy: Strategy에 해당한다. 각 무기가 구현해야 할 인터페이스를 정의한다.
- WeaponStrategyImpl: ConcreteStrategy에 해당한다. 폴더 내의 5개의 클래스가 5개의 무기에 맞는 동작을 정의한다.
- PlayerWeaponController: Context에 해당한다. 플레이어에게 입력을 전달받아 인터페이스를 호출하고, 플레이어 데이터(IPlayerContext)를 Strategy에 전달한다.
  - IPlayerContext: 알고리즘에서 필요로 하는 플레이어 데이터 인터페이스
- Player06: 예제 씬의 입출력을 위한 클래스 (마우스 우클릭, Q, W 입력받아 콘솔 로그 및 인스펙터창의 스탯으로 출력)